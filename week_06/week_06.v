
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module week_06(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	wire	[3:0] NUM1; // left two digits
	wire	[3:0] NUM2;	// middle two digits
	wire	[7:0] NUM3; // right two digits

	wire	[4:0] NUM1bcd; // bcd representation of NUM1
	wire	[4:0] NUM2bcd; // bcd representation of NUM2
	
	wire  PULSE_10us;  // clk pulse each 100us
	wire  PULSE_1ms;   // clk pulse each 1ms
	wire  pwm;		   // pulse widh modulation for brightnes of the display
	wire  count_up;    // counting up signal
	wire  count_down;  // counting down

	wire  [1:0] SW_debounced; // debounced SW
	
	

//=======================================================
//  Functional coding
//=======================================================

	segment7 digit0 (1'b1,NUM3[3:0],HEX0);
	segment7 digit1 (1'b1,NUM3[7:4],HEX1);

	segment7 digit2 (pwm,NUM2bcd[3:0],HEX2);
	segment7 digit3 (pwm,{3'b000,NUM2bcd[4]},HEX3);
	segment7 digit4 (pwm,NUM1bcd[3:0],HEX4);
	segment7 digit5 (pwm,{3'b000,NUM1bcd[4]},HEX5);

	assign NUM1 = SW[9:6];
	assign NUM2 = SW[5:2];

	assign LEDR[9:2] = SW[9:2];
	assign LEDR[1] = SW_debounced[1];
	assign LEDR[0] = SW_debounced[0];

	// bcd representation of NUM1 and NUM2
	bin2bcd #(.W(4)) u10(
	  .bin(NUM1),
	  .bcd(NUM1bcd)
	  );
	
	bin2bcd #(.W(4)) u11(
	  .bin(NUM2),
	  .bcd(NUM2bcd)
	  );
	
	// **************************************************
	// TASK 1: 
	//   a) build a new timer module in the file timer.v
	//   b) add clock enable input to the PWM module from last week
	//
	// result: NUM3 = 8, PWM is going like last week
	// 
	// **************************************************
	
	// timer 10us (100kHz)
	timer #(.WIDTH(9), .PERIOD(500)) u1(
		.clk(CLOCK_50),
		.out(PULSE_10us)
		);

	// timer 1ms (1kHz)
	timer #(.WIDTH(16), .PERIOD(50000)) u2(
		.clk(CLOCK_50),
		.out(PULSE_1ms)
		);

	// PWM module
	pwm u3(
		.clk(CLOCK_50),
		.clken(PULSE_10us),
		.duty(NUM3),
		.out(pwm)
	);

	
	// **************************************************
	// TASK 2: 
	//   a) build a new module for finding of rising edges in the file find_rise.v
	//   b) build a new synchronous up/down counter in the file up_down_counter.v
	//
	//   result: NUM3 is increasing in step 1 by pressing of the KEY[1], decreasing by KEY[0]
	//   note  : KEY on our board have analogue debouncing, this is reason why it is working
	// **************************************************

   
	find_rise u4(
		.clk(CLOCK_50),
		//.in(~KEY[0]), 	         // for the TASK 2
		//.in(SW[0]),			   // for the TASK 3
		.in(SW_debounced[0]), // for the TASK 4b
		.out(count_down)
	);

	find_rise u5(
		.clk(CLOCK_50),
		//.in(~KEY[1]),  	      // for the TASK 2
		//.in(SW[1]),			   // for the TASK 3
		.in(SW_debounced[1]), // for the TASK 4b
		.out(count_up)
	);
	
	
	// up/down counter
	up_down_counter u6(
		.clk(CLOCK_50),
		.up(count_up),
		.down(count_down),
		.data(NUM3)
		);

 	// **************************************************
	// TASK 3: change inputs of module find_rise from KEYs to SWitches
	//
	//   result: NUM3 is changing randomly when SW0/SW1 change state
	//   note  : SW on our board have not analogue debouncing
	// **************************************************
	
 	// **************************************************
	// TASK 4: 
	// 	a) build a new module for debouncing of switches in the file debouncer.v
	//		b) change inputs of module find_rise from KEYs to debounced SWitches
	//
	//  result: NUM3 is increasing/decreasing in step 1 by schanging of state SW0/SW1
	// **************************************************
	
	// debouncer SW[0]
	debouncer u7(
		.clk(CLOCK_50),
		.clken(PULSE_1ms),
		.in(SW[0]),
		.out(SW_debounced[0])
	);
	
	// debouncer SW[1]
	debouncer u8(
		.clk(CLOCK_50),
		.clken(PULSE_1ms),
		.in(SW[1]),
		.out(SW_debounced[1])
	);
	
	
endmodule
